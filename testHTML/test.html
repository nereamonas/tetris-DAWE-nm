<!DOCTYPE html>
<meta charset="utf-8">
<title>Test Suite</title>
<link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.15.0.css">
<body>
<canvas id="canvas" width="300" height="600"></canvas>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<script src="https://code.jquery.com/qunit/qunit-2.15.0.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.js"></script>
<script>
    function add(a, b) {
        return a + b;
    }

    var _slicer = Array.prototype.slice;

    function _getImagePixelData(canvas, x, y) {
        return _slicer.apply(canvas.getContext("2d").getImageData(x, y, 1, 1).data);
    }

    function _getPushContext(context) {
        var pushContext;

        if (context && typeof context.push === "function") {
            // `context` is an `Assert` context
            pushContext = context;
        }
        else if (context && context.assert && typeof context.assert.push === "function") {
            // `context` is a `Test` context
            pushContext = context.assert;
        }
        else if (
            QUnit && QUnit.config && QUnit.config.current && QUnit.config.current.assert &&
            typeof QUnit.config.current.assert.push === "function"
        ) {
            // `context` is an unknown context but we can find the `Assert` context via QUnit
            pushContext = QUnit.config.current.assert;
        }
        else if (QUnit && typeof QUnit.push === "function") {
            pushContext = QUnit.push;
        }
        else {
            throw new Error("Could not find the QUnit `Assert` context to push results");
        }

        return pushContext;
    }

    function pixelEqual(canvas, x, y, r, g, b, a, message) {
        if (typeof a === "string" && typeof message === "undefined") {
            message = a;
            a = undefined;
        }

        var actual = _getImagePixelData(canvas, x, y),
            expected = [r, g, b, a],
            pushContext = _getPushContext(this);

        if (typeof a === "undefined") {
            actual.pop();
            expected.pop();
        }

        message = message || "Pixel should be: " + _dumpArray(expected);
        pushContext.push(QUnit.equiv(actual, expected), actual, expected, message);
    }

    function notPixelEqual(canvas, x, y, r, g, b, a, message) {
        if (typeof a === "string" && typeof message === "undefined") {
            message = a;
            a = undefined;
        }

        var actual = _getImagePixelData(canvas, x, y),
            expected = [r, g, b, a],
            pushContext = _getPushContext(this);

        if (typeof a === "undefined") {
            actual.pop();
            expected.pop();
        }

        message = message || "Pixel should not be: " + _dumpArray(expected);
        pushContext.push(!QUnit.equiv(actual, expected), actual, expected, message);
    }



    //////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////       EJERCICIO 1      /////////////////////////////////////////////////

    var canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");



    // ============== Point =======================

    function Point (x, y) {
        this.x = x;
        this.y = y;
    }

    // ============== Rectangle ====================
    function Rectangle() {}

    Rectangle.prototype.init = function(p1,p2) {
        this.px = p1.x;
        this.py = p1.y;
        this.width = p2.x - p1.x;
        this.height = p2.y - p1.y;
        this.lineWidth= 1;
        this.color = 'black';
    }

    Rectangle.prototype.draw = function() {

        // TU CÓDIGO AQUÍ:
        // pinta un rectángulo del color actual en pantalla en la posición px,py, con
        // la anchura y altura actual y una línea de anchura=lineWidth. Ten en cuenta que
        // en este ejemplo la variable ctx es global y que guarda el contexto (context)
        // para pintar en el canvas.

        ctx.beginPath(); //preparamos para empezar a pintar el camino
        ctx.rect(this.px,this.py,this.width,this.height); //crear un cuadrado. x: desde la raiz x cuanto s separa de la pos 0. y: desde la raiz y cuanto se separa de la pos 0. width: la anchura q cogerá el cuadrado. heigth: la altura q cogerá el cuadrado
        ctx.closePath(); //Cerramos
        ctx.fillStyle=this.color;  //ponerle color al fondo
        ctx.lineWidth=this.lineWidth; //Asignamos la anchura del borde
        ctx.strokeStyle='black';   //ejer 4 - Ahora es necesario agregar está linea, ya q sino pierde el marco y se queda de color blanco
        ctx.fill();  //Rellenar el cuadrado
        ctx.stroke(); //bordear el cuadrado. por defecto es color negro y no dice nada d color

    }


    Rectangle.prototype.setLineWidth = function(width) { this.lineWidth=width}
    Rectangle.prototype.setFill = function(color) { this.color = color}

    /** Método introducido en el EJERCICIO 4 */

    Rectangle.prototype.move = function(x,y){
        this.px += x;
        this.py += y;
        this.draw();
    }

    /** Método introducido en el EJERCICIO 4 */

    Rectangle.prototype.erase = function(){
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth+2;
        ctx.strokeStyle = Tetris.BOARD_COLOR;
        ctx.rect(this.px, this.py, this.width, this.height);
        ctx.stroke();
        ctx.fillStyle = Tetris.BOARD_COLOR;
        ctx.fill()

    }


    // ============== Block ===============================

    function Block (pos, color) {

        // TU CÓDIGO AQUÍ: este es el constructor de la clase Block. Recibe dos parámetros, pos y color. Pos = posición de la casilla, por ejemplo, (9,19).
        // color = color que hay que emplear para pintar el bloque.
        // Internamente este método crea dos puntos (empleando las coordenadas del pixel)
        // y llama al método init de la clase Rectangle, pasándole como parámetro,
        // estos dos puntos.
        // Sería interesante que emplearas las constantes Block.BLOCK_SIZE y Block.OUTLINE_WIDTH,
        // para establecer la anchura del bloque y la anchura de la línea, respectivamente.

        this.x=pos.x; //cogemos la posicion x. Ejer5: Tenemos q guardarlo en this, xq en Block.prototype.can_move necesitamos coger la posicion actual. si no lo guardo en local, no podre coger esa informacion
        this.y=pos.y; //cogemos la posicion y. Ejer5: Tenemos q guardarlo en this, xq en Block.prototype.can_move necesitamos coger la posicion actual. si no lo guardo en local, no podre coger esa informacion

        //El punto1 tendra q ser la posicion dnd empezara el cuadrado(el punto de arriba a la izq) y el punto2 donde terminará(el punto de abajo a la derecha.
        //var puntoUno= new Point(this.x*Block.BLOCK_SIZE+Block.OUTLINE_WIDTH, this.y*Block.BLOCK_SIZE+Block.OUTLINE_WIDTH);   //tenemos q multiplicarlo por el tamaño del bloque. por ejemplo. nos llega q quiere el punto 0 - pues 0*30(q será la longitud del cuadrado)=0. empezará el punto en la pos 0. despues el 1. 1*30=30. empezará el cuadrado en la posicion 30, librando justo el bloque 0. si no lo multiplicariamos se solaparian los cubos. y asi sucesivamente.
        var puntoUno= new Point(this.x*Block.BLOCK_SIZE + Block.OUTLINE_WIDTH,this.y*Block.BLOCK_SIZE + Block.OUTLINE_WIDTH);  //(sumando eso me pasa el test, sino no :() Se suma el grosor de la linea. Todas las piezas se desplazaran 2 a la derecha y 2 hacia abajo
        var puntoDos= new Point(puntoUno.x+Block.BLOCK_SIZE,puntoUno.y+Block.BLOCK_SIZE); //Ya tenemos el punto 1 que será el principio del cuadrado, punto superior izq. Ahora crearemos el punto 2 que será el final, punto inferior derecho. X esta razon cogeremos el valos¡r x y del anterior punto, sumandole la lonjitud q tendrá el bloque. como antes si entra el punto 0. el puntoUno crearia la posicion (0,0) y aqui quedaria (30,30) sumando la lonjitud. si entra el 1, el puntoUno crearia (30,30) y el puntoDos(60,60). si entra el 2 - se crearia (60,60) y (90,90). asi sucesivamente

        this.init(puntoUno, puntoDos); //Llamamos al metodo init pasandole los dos puntos. para q cree el cuadrado

        //Una vez creado, se inicializa con LineWidth=1 y color=black por defecto. Asique con estos dos metodos ya implementados editaremos dichos valores

        this.setLineWidth(Block.OUTLINE_WIDTH); //El metodo ya creado para editar la anchura del borde. Tenemos el atr con dicho valor. Sino s podria usar this.lineWidth=Block.OUTLINE_WIDTH;

        this.setFill(color); //el metodo ya creado para establecer el color sino podriamos usar this.color=color;

    }

    Block.BLOCK_SIZE = 30;
    Block.OUTLINE_WIDTH = 2;

    // TU CÓDIGO AQUÍ: emplea el patrón de herencia (Block es un Rectangle)
    Block.prototype = new Rectangle();   //decimos q herede de rectangle
    Block.prototype.constructor = Block;  //indicamos q su contructor es block, que sino coge por defecto rectangle

    /** Método introducido en el EJERCICIO 4 */

    Block.prototype.move = function(dx, dy) {
        this.x += dx;
        this.y += dy;

        Rectangle.prototype.move.call(this, dx * Block.BLOCK_SIZE, dy * Block.BLOCK_SIZE);
    }

    /**************************************************
     *	 Código que se da dado para el EJERCICIO 5 *
     ***************************************************/

    Block.prototype.can_move = function(board, dx, dy) {
        // TU CÓDIGO AQUÍ: toma como parámetro un increment (dx,dy)
        // e indica si es posible mover el bloque actual si
        // incrementáramos su posición en ese valor
        canmove= board.can_move(this.x+dx, this.y+dy); // en this.x y this.y tenemos la posicion actual que hemos guardado al crear el bloque, asique incrementamos el dx y dy ha esas posiciones y llamamos al metodo de comprobar del board
        return canmove
    }

    // ************************************
    // *      EJERCICIO 2                  *
    // ************************************

    function Shape() {}


    Shape.prototype.init = function(coords, color) {

        // TU CÓDIGO AQUÍ: método de inicialización de una Pieza del tablero
        // Toma como parámetros: coords, un array de posiciones de los bloques
        // que forman la Pieza y color, un string que indica el color de los bloques
        // Post-condición: para cada coordenada, crea un bloque de ese color y lo guarda en un bloque-array
        //Se tiene que llamar blocks. porq los otros metodos ya implementados sino no lo cogen bien
        this.blocks=[]; //Creamos una lista que tendrá todos los bloques

        // Recorremos con forEarch todas las coordenadas q tiene el array coords, Con cada cordenada del array,
        // añadimos en la array de blockes un nuevo blocke con la cordenada y el color(q será para todos igual);
        coords.forEach(cordenada => this.blocks.push(new Block(cordenada,color)));

        /*8 Atributo introducido en el EJERCICIO 8*/
        this.rotation_dir = 1;

    };

    Shape.prototype.draw = function() {

        // TU CÓDIGO AQUÍ: método que debe pintar en pantalla todos los bloques
        // que forman la Pieza
        this.blocks.forEach(block => block.draw());   //Recorremos todos los blockes y con el metodo .draw() los pintaremos.

    };

    /**************************************************
     *	 Código que se da dado para el EJERCICIO 5 *
     ***************************************************/

    Shape.prototype.can_move = function(board, dx, dy) {
// TU CÓDIGO AQUÍ: comprobar límites para cada bloque de la pieza
        for (var i=0; i<this.blocks.length;i++){  //Tendremos q recorrer todos los bloques q forman la pieza
            canmove=this.blocks[i].can_move(board,dx,dy); //Llamamos al metodo del blocke para q nos diga si esa pieza se puede mover
            if (!canmove ) { //Si no se puede mover, automaticamente hacemos return false. no se seguira mirando
                return false;
            }
        }
        return true; //Si llegamos hasta aqui es porque to do ha ido correcto asique devolvemos true, es decir q la pieza se podra mover

    };

    /* Método introducido en el EJERCICIO 8 */

    Shape.prototype.can_rotate = function(board) {

//  TU CÓDIGO AQUÍ: calcula la fórmula de rotación para cada uno de los bloques de
// la pieza. Si alguno de los bloques no se pudiera mover a la nueva posición,
// devolver false. En caso contrario, true.

        //Parecido al can_move, pero aplicando la formula de x y
        for (var i=0;i<this.blocks.length;i++){  //Tendremos q recorrer todos los bloques q forman la pieza
            var block=this.blocks[i];
            var x = this.center_block.x -this.rotation_dir*this.center_block.y + this.rotation_dir*block.y   //la fórmula que nos permite rotar una casilla alrededor de otra un ángulo de 90 grados. Esta fórmula nos da las nuevas coordenadas del objeto block de tipo Bloque, cuando se rota alrededor del otro objeto center
            var y = this.center_block.y + this.rotation_dir*this.center_block.x -this.rotation_dir*block.x
            var canmove=board.can_move(x,y);
            if(!canmove){//Si no se puede mover, return false
                return false;
            }
        }
        return true;

    };

    /* Método introducido en el EJERCICIO 8 */

    Shape.prototype.rotate = function() {

// TU CÓDIGO AQUÍ: básicamente tienes que aplicar la fórmula de rotación
// (que se muestra en el enunciado de la práctica) a todos los bloques de la pieza

        //Cogemos el metodo move ya q será parecido. pero aplicando la formula de x y
        for (block of this.blocks) {
            block.erase();
        }

        for (block of this.blocks) {
            var x = this.center_block.x -this.rotation_dir*this.center_block.y + this.rotation_dir*block.y  //la fórmula que nos permite rotar una casilla alrededor de otra un ángulo de 90 grados. Esta fórmula nos da las nuevas coordenadas del objeto block de tipo Bloque, cuando se rota alrededor del otro objeto center
            var y = this.center_block.y + this.rotation_dir*this.center_block.x -this.rotation_dir*block.x
            block.move(x-block.x,y-block.y); //Movemos la pieza pero aplicando las cordenadas
        }


        /* Deja este código al final. Por defecto las piezas deben oscilar en su
           movimiento, aunque no siempre es así (de ahí que haya que comprobarlo) */
        if (this.shift_rotation_dir)
            this.rotation_dir *= -1
    };

    /* Método introducido en el EJERCICIO 4 */

    Shape.prototype.move = function(dx, dy) {

        for (block of this.blocks) {
            block.erase();
        }

        for (block of this.blocks) {
            block.move(dx,dy);
        }
    };


    // ============= I_Shape ================================
    function I_Shape(center) {
        var coords = [new Point(center.x - 2, center.y),
            new Point(center.x - 1, center.y),
            new Point(center.x , center.y),
            new Point(center.x + 1, center.y)];

        Shape.prototype.init.call(this, coords, "blue");

        /* Atributo introducido en el ejercicio 8*/

        this.shift_rotation_dir = true;
        this.center_block = this.blocks[2];

    }

    // TU CÓDIGO AQUÍ: La clase I_Shape hereda de la clase Shape
    I_Shape.prototype = new Shape();   //decimos q herede de Shape
    I_Shape.prototype.constructor = I_Shape;  //indicamos q su contructor es I_Shape, que sino coge por defecto Shape


    // =============== J_Shape =============================
    function J_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar J_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y),
            new Point(center.x , center.y),//centro
            new Point(center.x+1 , center.y),
            new Point(center.x+1 , center.y+1)];  //curiosamente es +

        Shape.prototype.init.call(this, coords, "orange");

        /* atributo introducido en el EJERCICIO 8 */
        this.shift_rotation_dir = false;  //Esta pieza siempre rota en el mismo sentido. asiq pondremos a false el shift_rotation_dir
        this.center_block = this.blocks[1];

    }

    // TU CÓDIGO AQUÍ: La clase J_Shape hereda de la clase Shape
    J_Shape.prototype = new Shape();   //decimos q herede de Shape
    J_Shape.prototype.constructor = J_Shape;  //indicamos q su contructor es J_Shape, que sino coge por defecto Shape

    // ============ L Shape ===========================
    function L_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar L_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y),
            new Point(center.x-1 , center.y+1),
            new Point(center.x , center.y),//centro
            new Point(center.x+1 , center.y)];

        Shape.prototype.init.call(this, coords, "cyan");

        /* atributo introducido en el EJERCICIO 8 */
        this.shift_rotation_dir = false;  //Esta pieza siempre rota en el mismo sentido. asiq pondremos a false el shift_rotation_dir
        this.center_block = this.blocks[1];

    }

    // TU CÓDIGO AQUÍ: La clase L_Shape hereda de la clase Shape
    L_Shape.prototype = new Shape();   //decimos q herede de Shape
    L_Shape.prototype.constructor = L_Shape;  //indicamos q su contructor es L_Shape, que sino coge por defecto Shape


    // ============ O Shape ===========================
    function O_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar O_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y),
            new Point(center.x-1 , center.y+1),
            new Point(center.x , center.y),//centro
            new Point(center.x , center.y+1)];

        Shape.prototype.init.call(this, coords, "red");

        /* atributo introducido en el EJERCICIO 8 */

        this.center_block = this.blocks[0];

    }

    // TU CÓDIGO AQUÍ: La clase O_Shape hereda de la clase Shape
    O_Shape.prototype = new Shape();   //decimos q herede de Shape
    O_Shape.prototype.constructor = O_Shape;  //indicamos q su contructor es O_Shape, que sino coge por defecto Shape

    /* Código introducido en el EJERCICIO 8*/
    // O_Shape la pieza no rota. Sobreescribiremos el método can_rotate que ha heredado de la clase Shape

    O_Shape.prototype.can_rotate = function(board){
        return false;
    };

    // ============ S Shape ===========================
    function S_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar S_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y+1),
            new Point(center.x , center.y+1),
            new Point(center.x , center.y), //centro
            new Point(center.x + 1, center.y)];

        Shape.prototype.init.call(this, coords, "green");

        /* atributo introducido en el EJERCICIO 8 */


        this.shift_rotation_dir = true;
        this.center_block = this.blocks[0];


    }

    // TU CÓDIGO AQUÍ: La clase S_Shape hereda de la clase Shape
    S_Shape.prototype = new Shape();   //decimos q herede de Shape
    S_Shape.prototype.constructor = S_Shape;  //indicamos q su contructor es S_Shape, que sino coge por defecto Shape

    // ============ T Shape ===========================
    function T_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar S_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y),
            new Point(center.x , center.y),//centro
            new Point(center.x , center.y+1),
            new Point(center.x + 1, center.y)];

        Shape.prototype.init.call(this, coords, "yellow");

        /* atributo introducido en el EJERCICIO 8 */
        this.shift_rotation_dir = false;    //Esta pieza siempre rota en el mismo sentido. asiq pondremos a false el shift_rotation_dir
        this.center_block = this.blocks[1];


    }

    // TU CÓDIGO AQUÍ: La clase T_Shape hereda de la clase Shape
    T_Shape.prototype = new Shape();   //decimos q herede de Shape
    T_Shape.prototype.constructor = T_Shape;  //indicamos q su contructor es T_Shape, que sino coge por defecto Shape


    // ============ Z Shape ===========================
    function Z_Shape(center) {

        // TU CÓDIGO AQUÍ: Para programar S_Shape toma como ejemplo el código de la clase I_Shape
        var coords = [new Point(center.x - 1, center.y),
            new Point(center.x , center.y),//centro
            new Point(center.x , center.y+1),
            new Point(center.x + 1, center.y+1)];

        Shape.prototype.init.call(this, coords, "magenta");

        /* atributo introducido en el EJERCICIO 8 */

        this.shift_rotation_dir = true;
        this.center_block = this.blocks[1];
    }

    // TU CÓDIGO AQUÍ: La clase Z_Shape hereda de la clase Shape
    Z_Shape.prototype = new Shape();   //decimos q herede de Shape
    Z_Shape.prototype.constructor = Z_Shape;  //indicamos q su contructor es Z_Shape, que sino coge por defecto Shape


    // ************************************
    // *     EJERCICIO 3               *
    // ************************************

    // ====================== BOARD ================

    function Board(width, height) {
        this.width = width;
        this.height = height;
        this.grid = {}; /* 6. Estructura de datos introducida en el EJERCICIO 6 */
    }


    // Si la pieza nueva puede entrar en el tablero, pintarla y devolver true.
    // Si no, devoler false

    Board.prototype.draw_shape = function(shape){
        if (shape.can_move(this,0,0)){
            shape.draw();
            return true;
        }
        return false;
    }

    /*****************************
     *	 EJERCICIO 6          *
     *****************************/

    Board.prototype.add_shape = function(shape){

// TU CÓDIGO AQUÍ: meter todos los bloques de la pieza que hemos recibido por parámetro en la estructura de datos grid
        for (var i=0;i<shape.blocks.length;i++){
            var block=shape.blocks[i];
            var x= block.x;
            var y= block.y;
            var tuplaxy=""+x+","+y+"";
            this.grid[tuplaxy]=block;
        }
    }

    // ****************************
    // *     EJERCICIO 5          *
    // ****************************

    Board.prototype.can_move = function(x,y){

        // TU CÓDIGO AQUÍ:
        // hasta ahora, este método siempre devolvía el valor true. Ahora,
        // comprueba si la posición que se le pasa como párametro está dentro de los
        // límites del tablero y en función de ello, devuelve true o false.

        /* EJERCICIO 7 */
        // TU CÓDIGO AQUÍ: código para detectar colisiones. Si la posición x,y está en el diccionario grid, devolver false y true en cualquier otro caso.

        var canmove=false;
        if ((x<this.width && x>=0)&&(y>=0 && y<this.height) ){//Comprobamos q el punto x e y que nos pasan está dentro de los limites del tablero. es decir entre 0 y la anchura max o altura max
            var item=""+x+","+y+""; //Creamos el item igual q cuando los añadimos al grid
            if (!(item in this.grid)){ //si el elemento no esta en grid, la piezsa podrá moverse a esa posicion asiq ponemos canmove=true
                canmove= true;
            }

        }
        return canmove;
    };

    Board.prototype.is_row_complete = function(y){
// TU CÓDIGO AQUÍ: comprueba si la línea que se le pasa como parámetro
// es completa o no (se busca en el grid).

        for (var x = 0; x < this.width; x++) { //Recorreremos todas las x
            item = x + "," + y;  //Sacamos el item
            if (!( item in this.grid )) {  //Comprobamos si el item no esta en el grid
                return false;  //Como el item no está dentro devolvemos false directamente. no hay q seguir mirando
            }
        }
        return true; //Si ha recorrido to do el for y ha llegado hasta aqui es que la linea esta completa

    };

    Board.prototype.delete_row = function(y){
// TU CÓDIGO AQUÍ: Borra del grid y de pantalla todos los bloques de la fila y
        for (var x = 0; x < this.width; x++) { //Recorreremos todas las x
            item = x + "," + y;  //Sacamos el item
            this.grid[item].erase();  //Importante borramos el actual elemento del dibujo
            delete this.grid[item]; //Lo eliminamos del grid
        }


    };

    Board.prototype.move_down_rows = function(y_start){
/// TU CÓDIGO AQUÍ:
//  empezando en la fila y_start y hasta la fila 0
        for ( var y = y_start; y >= 0; y-- ) {
//    para todas las casillas de esa fila
            for (var x = 0; x < this.width; x++) {
//       si la casilla está en el grid  (hay bloque en esa casilla)
                item = x + "," + y;  //Aplicamos el patron que tienen los elementos del grid
                if (item in this.grid) {
                    var block = this.grid[item];
//            borrar el bloque del grid
                    delete this.grid[item];
//          mientras se pueda mover el bloque hacia abajo
                    dx = Tetris.DIRECTION['Down'][0];
                    dy = Tetris.DIRECTION['Down'][1];
                    if (block.can_move(this,dx,dy)){
//              mover el bloque hacia abajo
                        block.erase(); //lo borramos del sitio donde esta. importante
                        block.move(dx,dy); //lo movemos una casilla hacia abajo
                    }
//          meter el bloque en la nueva posición del grid
                    this.grid[block.x+','+block.y] = block;  //cogemos la posicion x y actual del bloque

                }
            }
        }



    };

    Board.prototype.remove_complete_rows = function(){
// TU CÓDIGO AQUÍ:
// Para toda fila y del tablero
        for (var y=0; y<=this.height; y++) {
//   si la fila y está completa
            if (this.is_row_complete(y)) {
//      borrar fila y
                this.delete_row(y);
//      mover hacia abajo las filas superiores (es decir, move_down_rows(y-1) )
                this.move_down_rows(y - 1);
            }
        }

    };

    var gameOver = false;
    Board.prototype.game_over = function() {
        console.log("GAMEOVER");

        // Mostrar mensaje de game over en el canvas
        ctx.font = "50px Tetris";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

    }

    // ==================== Tetris ==========================

    function Tetris() {
        this.board = new Board(Tetris.BOARD_WIDTH, Tetris.BOARD_HEIGHT);
    }

    Tetris.SHAPES = [I_Shape, J_Shape, L_Shape, O_Shape, S_Shape, T_Shape, Z_Shape];
    Tetris.DIRECTION = {'Left':[-1, 0], 'Right':[1, 0], 'Down':[0, 1]};
    Tetris.BOARD_WIDTH = 10;
    Tetris.BOARD_HEIGHT = 20;
    Tetris.BOARD_COLOR='white';

    Tetris.prototype.create_new_shape = function(){

        // TU CÓDIGO AQUÍ:
        // Elegir un nombre de pieza al azar del array Tetris.SHAPES
        // Crear una instancia de ese tipo de pieza (x = centro del tablero, y = 0)
        // Devolver la referencia de esa pieza nueva

        var randomNumber=Math.floor(Math.random()*Tetris.SHAPES.length);  //Cogemos un numero random del 0 al 6. La longitud del array es 7. pero el ultimo no lo coge https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random
        var shape= Tetris.SHAPES[randomNumber]  //Devolvemos el shapes referente a la posicion del numero aleatorio

        var center=Math.trunc(Tetris.BOARD_WIDTH/2);  //el centro del x será la largura del tablero / 2. como puede dar un numero con comas, con esta funcion devolvera el entero.
        var newpoint= new Point(center,0); //Creamos la pieza con la x=centro, y=0

        var piezaNueva= new shape(newpoint);  //shape cogera valor x ejemplo de I_Shape. Asique crearemos un I_shape como atributo pasandole el punto central
        //var piezaNueva= new S_Shape(newpoint);  //Para pasar el test del ejercicio 4, 5 y 6(parte 1) - Para este ejercicio creamos una S_SHAPE SIEMPRE.  tendremos q descomentar esta linea

        return piezaNueva  //Devolvemos la referencia a la nueva pieza

    }

    Tetris.prototype.init = function(){

        /**************
         EJERCICIO 4
         ***************/

        // gestor de teclado

        document.addEventListener('keydown', this.key_pressed.bind(this), false);

        // Obtener una nueva pieza al azar y asignarla como pieza actual

        this.current_shape = this.create_new_shape()

        // TU CÓDIGO AQUÍ:
        // Pintar la pieza actual en el tablero
        // Aclaración: (Board tiene un método para pintar)
        this.board.draw_shape(this.current_shape);  //Llamamos al metodo de pintar de board y le pasamoa la pieza actual para q la pinte


        // Crea el código del método Tetris.animate_shape (más abajo lo verás)
        this.animate_shape();

    }

    Tetris.prototype.key_pressed = function(e) {

        var key = e.keyCode ? e.keyCode : e.which;

        // TU CÓDIGO AQUÍ:
        // en la variable key se guardará el código ASCII de la tecla que
        // ha pulsado el usuario. ¿Cuál es el código key que corresponde
        // a mover la pieza hacia la izquierda, la derecha, abajo o a rotarla?
        console.log("Tecla pulsada: "+e.key+"  key: "+key);

        if (key==39){  //Derecha
            this.do_move("Right");
        }else if (key==37){  //Izquierda
            this.do_move("Left");
        }else if (key==40){  //Abajo
            this.do_move("Down");
        }else if (key==32){  //Barra espaciadora
            this.do_move("Space");
        }else if (key==38){  //Arriba
            this.do_rotate();
        }
        /* Introduce el código para realizar la rotación en el EJERCICIO 8. Es decir, al pulsar la flecha arriba, rotar la pieza actual */
    }

    Tetris.prototype.do_move = function(direction) {

        // TU CÓDIGO AQUÍ: el usuario ha pulsado la tecla Left, Right o Down (izquierda,
        // derecha o abajo). Tenemos que mover la pieza en la dirección correspondiente
        // a esa tecla. Recuerda que el array Tetris.DIRECTION guarda los desplazamientos
        // en cada dirección, por tanto, si accedes a Tetris.DIRECTION[direction],
        // obtendrás el desplazamiento (dx, dy). A continuación analiza si la pieza actual
        // se puede mover con ese desplazamiento. En caso afirmativo, mueve la pieza.

        var piezaFinal=false;
        if (direction=='Space'){

            while(this.current_shape.can_move(this.board, 0, 1)) {  //Iteramos bajando hasta llegar hasta abajo//Tenemos un metodo que nos devolverá true si ese shape puede moverse, pasandole el board y las direcciones de movimiento.
                this.current_shape.move(0, 1); //Llamamos al metodo para que nos mueva la piza actual pasandole las direcciones de movimiento
            }
            piezaFinal=true;//Una vez hemos llegado abajo ponemos este atributo a true para fijar la pieza

        }else {

            dx = Tetris.DIRECTION[direction][0];
            dy = Tetris.DIRECTION[direction][1];

            if (this.current_shape.can_move(this.board, dx, dy)) {  //Tenemos un metodo que nos devolverá true si ese shape puede moverse, pasandole el board y las direcciones de movimiento.
                this.current_shape.move(dx, dy); //Llamamos al metodo para que nos mueva la piza actual pasandole las direcciones de movimiento
            }

                /* Código que se pide en el EJERCICIO 6 */
                // else if(direction=='Down')
            // TU CÓDIGO AQUÍ: añade la pieza actual al grid. Crea una nueva pieza y dibújala en el tablero.
            else if (direction == 'Down') { //Si cuando la pieza falla el ultimo movimiento es down.
                piezaFinal=true; //un atributo para fijar la pieza luego
            }
        }
        if (piezaFinal){
            this.board.add_shape(this.current_shape); //Añadimos la pieza actual al tablero;
            this.current_shape = this.create_new_shape();//Actualizamos el valor del atributo a una nueva pieza al azar
            this.board.draw_shape(this.current_shape); //Dibujar la nueva pieza en el tablero
            //Llamar a remove_complete_rows
            this.board.remove_complete_rows();
            // Comprobamos si la nueva pieza puede entrar o ha terminado el juego
            if(!this.current_shape.can_move(this.board, 0, 0)){  //Como cuando pintamos una pieza. primero comprobamos que se pueda mover ahi para pintar. si no se puede mover, es que se ha acabado el huego porq no hay huevo libre
                this.board.game_over();
                clearInterval(this.interval);  //Tenemos que parar el interval porq sino siue intenetando sacar piezas.
            }
        }

    }

    /***** EJERCICIO 8 ******/
    Tetris.prototype.do_rotate = function(){

        // TU CÓDIGO AQUÍ: si la pieza actual se puede rotar, rótala. Recueda que Shape.can_rotate y Shape.rotate ya están programadas.
        if (this.current_shape.can_rotate(this.board)){
            this.current_shape.rotate(this.board);
        }
    }

    Tetris.prototype.animate_shape = function(){
// TU CÓDIGO AQUÍ: genera un timer que mueva hacia abajo la pieza actual cada segundo
        var tetris = this;
        this.interval=setInterval(function(){tetris.do_move('Down')},1000);
    }



    // ===== main ====

    // variables globales para acceder al canvas
    //var canvas = document.getElementById("canvas");
    //var ctx = canvas.getContext("2d");





    QUnit.module('EJERCICIO 1', function() {
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height); //
        var block1 = new Block(new Point(0,0), 'red'),
            block2 = new Block(new Point(1,1), 'blue'),
            block3 = new Block(new Point(2,2), 'green');

        block1.draw();
        block2.draw();
        block3.draw();

        QUnit.test( "Subclases", function( assert ) {
            assert.ok( block1 instanceof Block , "Passed!" );
            assert.ok( block1 instanceof Rectangle , "Passed!" );

            assert.ok( block2 instanceof Block , "Passed!" );
            assert.ok( block2 instanceof Rectangle , "Passed!" );
        });

        QUnit.test('pixel equal test', function(assert) {
            // assert.pixelEqual(canvas, x, y, r, g, b, a, message);
            pixelEqual(canvas, 15, 15, 255, 0, 0, 255, "Passed!");
            pixelEqual(canvas, 45, 45, 0, 0, 255, 255, "Passed!");
            pixelEqual(canvas, 75, 75, 0, 128, 0, 255, "Passed!");
        });
    });


    QUnit.module('EJERCICIO 2.1', function() {
        // clear the canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height); //

        var shape = new I_Shape(new Point(3, 1));
        shape.draw();

        QUnit.test( "Subclases", function( assert ) {
            assert.ok( shape instanceof Shape, "Passed!" );
            assert.ok( shape instanceof I_Shape , "Passed!" );
        });

        QUnit.test('pixel equal test', function(assert) {
            // assert.pixelEqual(canvas, x, y, r, g, b, a, message);
            pixelEqual(canvas, 15, 45, 255, 255, 255, 255, "Blanco");
            pixelEqual(canvas, 45, 45, 0, 0, 255, 255, "Azul1");
            pixelEqual(canvas, 75, 45, 0, 0, 255, 255, "Azul2");
            pixelEqual(canvas, 105, 45, 0, 0, 255, 255, "Azul3");
            pixelEqual(canvas, 135, 45, 0, 0, 255, 255, "Azul4");
        });

    });

    QUnit.module('EJERCICIO 2.2', function() {

        // canvas related variables
        var canvas = document.getElementById("canvas");
        canvas.setAttribute("width",1000);
        var ctx = canvas.getContext("2d");

        // clear the canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height); //

        var tetrominos = [I_Shape, J_Shape, L_Shape, O_Shape, S_Shape, T_Shape, Z_Shape];
        x = 3;
        var shapes = [];
        tetrominos.forEach( function ( tetromino ) {
            shape = new tetromino(new Point(x, 1));
            shapes.push(shape);
            shape.draw();
            x += 4;
        });

        QUnit.test( "Subclases", function( assert ) {
            assert.ok( shapes[0] instanceof Shape, "Passed!" );
            assert.ok( shapes[0] instanceof I_Shape , "Passed!" );

            assert.ok( shapes[1] instanceof Shape, "Passed!" );
            assert.ok( shapes[1] instanceof J_Shape , "Passed!" );

            assert.ok( shapes[2] instanceof Shape, "Passed!" );
            assert.ok( shapes[2] instanceof L_Shape , "Passed!" );

            assert.ok( shapes[3] instanceof Shape, "Passed!" );
            assert.ok( shapes[3] instanceof O_Shape , "Passed!" );

            assert.ok( shapes[4] instanceof Shape, "Passed!" );
            assert.ok( shapes[4] instanceof S_Shape , "Passed!" );

            assert.ok( shapes[5] instanceof Shape, "Passed!" );
            assert.ok( shapes[5] instanceof T_Shape , "Passed!" );

            assert.ok( shapes[6] instanceof Shape, "Passed!" );
            assert.ok( shapes[6] instanceof Z_Shape , "Passed!" );
        });

        QUnit.test('pixel equal test', function(assert) {
            // assert.pixelEqual(canvas, x, y, r, g, b, a, message);
        //    ctx.fillStyle = 'black';
        //    ctx.fillRect(15*8*2,45,4,4);
            pixelEqual(canvas, 15, 45, 255, 255, 255, 255, "White");
            pixelEqual(canvas, 15*3*2, 45, 0, 0, 255, 255, "Blue");
            pixelEqual(canvas, 15*8*2, 45, 255, 165, 0, 255, "Orange");
            pixelEqual(canvas, 15*12*2, 45, 0, 255, 255, 255, "Cyan");
            pixelEqual(canvas, 15*16*2, 45, 255, 0, 0, 255, "Red");
            pixelEqual(canvas, 15*21*2, 45, 0, 128, 0, 255, "Green");
            pixelEqual(canvas, 15*24*2, 45, 255, 255, 0, 255, "Yellow");
            pixelEqual(canvas, 15*28*2, 45, 255, 0, 255, 255, "Magenta");
        });


    });



    QUnit.module('EJERCICIO 3', function() {

        // clear the canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        var game = new Tetris();
        game.init();

        QUnit.test( "Existencia de Clases", function( assert ) {
            assert.ok( game instanceof Tetris, "Passed!" );
        });

        QUnit.test( "Existencia de atributo current_shape", function( assert ) {
            assert.ok( game.current_shape instanceof Shape, "Es una pieza" );
            for (t of Tetris.SHAPES)
                if (t.name == game.current_shape.constructor.name)
                    assert.equal(t, game.current_shape.constructor,"Es una de las 7 posibles");
        });

        QUnit.test('pixel equal test', function(assert) {
            // assert.pixelEqual(canvas, x, y, r, g, b, a, message);
            // ctx.fillStyle = 'black';
            // ctx.fillRect(15*5*2+10,15,4,4);
            pixelEqual(canvas, 15, 45, 255, 255, 255, 255, "White");
            notPixelEqual(canvas, 15*5*2+10, 10, 255, 255, 255, 255, "! White");

        });

    });

/*

    QUnit.module('EJERCICIO 4', function() {

// clear the canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height); //


        game = new Tetris();
        game.init();

        QUnit.test('Testing movements', function(assert) {
            // ctx.fillStyle = 'red';
            // ctx.fillRect(15*3*3,15,4,4);

            // SE ha modificado el método que crea la pieza actual
            // para que siempre devuelva la S
            // inicialmente esta posición debe ser blanca
            pixelEqual(canvas, 15*3*3, 15, 255, 255, 255, 255, "Inicialmente White");
            // si movemos la pieza 24 veces hacia la izquierda, debe ser verde
            for(i=1;i<=24;i++)
                game.do_move("Left");

            pixelEqual(canvas, 15*3*3, 15, 0, 128, 0, 255, "Green al moverse a la izquierda");

            // si movemos ahora la pieza 24 veces hacia abajo, debe ser blanca otra vez

            for(i=1;i<=24;i++)
                game.do_move("Down");

            pixelEqual(canvas, 15*3*3, 15, 255, 255, 255, 255, "White al moverla hacia abajo");


            // y el bloque que está 24 posiciones más abajo, verde

            pixelEqual(canvas, 15*3*3, 15+24, 0, 128, 0, 255, "Green un poco más abajo");

            // si movemos la pieza 24 veces a la derecha, debe ser blanca otra vez
            for(i=1;i<=24;i++)
                game.do_move("Right");

            pixelEqual(canvas, 15*3*3, 15, 255, 255, 255, 255, "White tras volver a mover la pieza hacia la derecha");


        });

    });



    QUnit.module('EJERCICIO 6', function() {

// clear the canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width,canvas.height); //


        game = new Tetris();
        game.init();


// Hemos creado un pequeño tablero de 10x5 para estos tests
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'blue';
        for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
            ctx.stroke();
        }

        for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
            ctx.stroke();
        }

        QUnit.test('Testing functions', function(assert) {
            assert.ok(  game.board.add_shape instanceof Function , "Board add_shape es una función");
        });

        QUnit.test('Testing grid', function(assert) {
            // si movemos la pieza 4 veces hacia abajo, el bloque
            // situado en 4,4, debe ser verde
            for(var i=1;i<=4;i++)
                game.do_move("Down");

            // ctx.fillStyle = 'red';
            // ctx.fillRect(30*4+15,30*4+15,4,4);

            pixelEqual(canvas, 30*4+15, 30*4+15, 0, 128, 0, 255, "Green al moverser 4 veces hacia abajo")

            assert.ok( game.board.grid["5,3"] instanceof Block, "Grid tiene bloque en 5,3");

            assert.ok( game.board.grid["5,4"] instanceof Block, "Grid tiene bloque en 5,4");

            assert.ok( game.board.grid["6,3"] instanceof Block, "Grid tiene bloque en 6,3");

            assert.ok( game.board.grid["4,4"] instanceof Block, "Grid tiene bloque en 4,4");

        });

        QUnit.test('Sale pieza nueva', function(assert) {

            // en este test no saldrá una nueva pieza al azar en la
            // parte superior, sino que saldrá otra S

            // ctx.fillStyle = 'red';
            // ctx.fillRect(30*5+15,14,4,4);

            pixelEqual(canvas, 30*5+15, 15, 0, 128, 0, 255, "Green en la parte superior");

        });



    });

    */
        QUnit.module('EJERCICIO 6.2', function() {

    // clear the canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height); //

            game = new Tetris();
            game.init();

    // Hemos creado un pequeño tablero de 10x5 para estos tests
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'blue';
            for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
                ctx.stroke();
            }

            for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
                ctx.stroke();
            }

            var doc = $(document);
            doc.keydown( function( event ) {
                game.key_pressed(event);
            }).trigger( // left
                jQuery.Event( 'keydown', { keyCode: 32, which: 32 } )
            );
            game.key_pressed(32);

            QUnit.test('Testing SpaceBar ', function(assert) {
                // Para este test hemos creado un tablero de 10x10.
                // Y las piezas se generan al azar (no siempre la S)
                // simulamos una pulsación de teclado

                var allBlocks = true;
                for(var block in game.board.grid)
                    allBlocks = game.board.grid[block] instanceof Block && allBlocks;

                assert.ok(allBlocks, "Hay 4 bloques en el grid");

                var deColor = 0;
                // al menos 2 casillas de color en la primera fila
                for (var block of game.current_shape.blocks)
                    if (block.y == 0)
                        deColor++;

                assert.ok(deColor >= 2, "al menos 2 casillas de color en la primera fila");
            });
        });






        QUnit.module('EJERCICIO 7', function() {

    // clear the canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height); //


            game = new Tetris();
            game.init();

    // Hemos creado un pequeño tablero de 10x5 para estos tests
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'blue';
            for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
                ctx.stroke();
            }

            for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
                ctx.stroke();
            }


            QUnit.test('Testing Board.can_move ', function(assert) {

                // Para este test hemos creado un tablero de 10x10.
                // Y las piezas se generan al azar (no siempre la S)

                var pieza = game.create_new_shape();
                // metemos la nueva pieza al grid para hacer el test
                game.board.add_shape(pieza);
                // no deberíamos poder mover una pieza a la posición superior del tablero
                assert.ok(!game.board.can_move(5,0), "no podemos mover una pieza a una posición ya ocupada");

            });


        });


        QUnit.module('EJERCICIO 8.1', function() {

    // clear the canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height); //


            game = new Tetris();
            game.init();

    // Hemos creado un pequeño tablero de 10x5 para estos tests
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'blue';
            for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
                ctx.stroke();
            }

            for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
                ctx.stroke();
            }


            QUnit.test('Testing: las funciones de rotación existen ', function(assert) {
                assert.ok( game.do_rotate instanceof Function, "Tetris.do_rotate existe");
                assert.ok( game.current_shape.can_rotate instanceof Function, "Shape.can_rotate existe");
                assert.ok( game.current_shape.rotate instanceof Function, "Shape.rotate existe");
            });

            QUnit.test('Testeando la rotación', function(assert) {

                // Para este test hemos creado un tablero de 10x10.
                // Y las piezas se generan al azar (no siempre la S)

                var pieza = game.create_new_shape();

                assert.ok(! game.current_shape.can_rotate(game.board) , "No deberíamos poder rotar");

                // movemos la pieza 4 veces hacia abajo
                for (var i=1; i <= 4; i++)
                    game.do_move("Down");


                if (!( pieza instanceof O_Shape))
                    assert.ok(game.current_shape.can_rotate(game.board) , "Ahora deberíamos poder rotar");

            });

        });

        QUnit.module('EJERCICIO 8.2', function() {

    // clear the canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height); //


            var game = new Tetris();
            game.init();

    // Hemos creado un pequeño tablero de 10x5 para estos tests
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'blue';
            for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
                ctx.stroke();
            }

            for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
                ctx.stroke();
            }


            QUnit.test('Testing: la función Tetris.animate_shape existe', function(assert) {
                assert.ok( game.animate_shape instanceof Function, "Tetris.animate_shape existe");
            });



            QUnit.test('Testeando la rotación', function(assert) {

                var done = assert.async();

                // Para este test hemos creado un tablero de 10x10.
                // Y las piezas se generan al azar (no siempre la S)

                var pieza = game.create_new_shape();

                setTimeout(function() {
                    var gridLength = 0; for(var block in game.board.grid) gridLength++;
                    assert.ok( gridLength == 4 , "El temporizador se ha puesto en marcha y la pieza original ha caído hasta abajo sola" );
                    done();
                }, Tetris.BOARD_HEIGHT * 1000 );

            });
        });




        QUnit.module('EJERCICIO 8.3', function() {

    // clear the canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height); //


            game = new Tetris();
            game.init();

    // Hemos creado un pequeño tablero de 10x5 para estos tests
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'blue';
            for (var x=0; x < Tetris.BOARD_WIDTH*30; x=x+30){
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, Tetris.BOARD_HEIGHT*30);
                ctx.stroke();
            }

            for (var y=0; y < Tetris.BOARD_HEIGHT*30; y=y+30){
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(Tetris.BOARD_WIDTH*30, y);
                ctx.stroke();
            }


            QUnit.test('Testing: las funciones existen', function(assert) {
                assert.ok( game.board.is_row_complete instanceof Function, "Board.is_row_complete existe");
                assert.ok( game.board.delete_row instanceof Function, "Board.delete_row existe");
                assert.ok( game.board.move_down_rows instanceof Function, "Board.move_down_rows existe");
                assert.ok( game.board.remove_complete_rows instanceof Function, "Board.remove_complete_rows existe");

            });

            QUnit.test('Testeando las funciones de línea completa', function(assert) {

                // Para este test hemos creado un tablero de 10x10.
                // Creamos dos filas completas de bloques en la parte inferior del grid

                for (var fila=Tetris.BOARD_HEIGHT-2; fila<Tetris.BOARD_HEIGHT; fila++){
                    for (var i=0; i<Tetris.BOARD_WIDTH; i++){
                        var pos = new Point(i, fila);
                        game.board.grid["".concat(i,",",fila)] = new Block(pos,"blue");
                    }
                }

                assert.ok( game.board.is_row_complete(Tetris.BOARD_HEIGHT-1) , "La última fila es completa" );
                assert.ok( game.board.is_row_complete(Tetris.BOARD_HEIGHT-2) , "La penúltima fila es completa" );

                // borrar las filas completas
                game.board.remove_complete_rows();

                assert.ok(! game.board.is_row_complete(Tetris.BOARD_HEIGHT-1) , "La última fila no es completa" );
                assert.ok(! game.board.is_row_complete(Tetris.BOARD_HEIGHT-2) , "La penúltima fila no es completa" );

            });

        });


    //Bien: 1,2,3,7,8

</script>







</body>